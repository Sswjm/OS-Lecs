# OSTEP作业  

# Ch.4 抽象：进程（Abstraction:Process）  
1 cpu利用率应该是100%；两个进程都没有I/O操作，CPU一直在运行  
2 11个时间单位
3 运行时间明显缩短，为7个时间单位；重要，某个进程由于I/O进入blocked状态时，cpu可以运行其他进程，从而提高cpu利用率  
4 运行时间与2相同，因为一个进程阻塞时，不允许另一个进程调度（先来先服务且不允许抢占）  
5 运行时间与3相同，因为在IO操作时允许进程调度    
6 运行这个进程组合时，设置当IO完成时，发出IO的进程不一定马上运行。PID0进程被阻塞后，先后运行1、2、3，其皆运行结束之后才继续运行进程PID0。这种方式系统资源利用率较低，cpu利用率仅为67.74%。   
7 设置立即运行发出IO的进程。这种方式可以在每次IO进程阻塞时，运行另一个进程，顺序为0、1、0、2、0、3，这样可以充分利用cpu资源，这个例子中达到了100%。  
8 预测随机生成的进程即可。  

# CH.5 插叙：进程API（Interlude:Process API）  
Simulation:  
1、2 思考进程fork时的进程树  
3 根据进程树推测执行哪种syscall  
4 执行`./fork.py -A a+b,b+c,c+d,c+e,c-`子进程退出时，进程c的子进程变为a（根结点）的子进程。加入`-R`参数后（表示reparent to local parent），c的子进程d和e变为b的子进程。  
5 根据进程fork和exit序列创建进程树  
6 根据进程树考虑syscall序列  

Code:  
代码位于ostep-homework/cpu-api，这里我没有写makefile，每次写完一个程序都使用gcc编译来检查结果  
1 父进程和子进程都会单独改变局部变量x的值。父进程中，改变前x = 100， 改变后x = 7， 最终程序输出7；子进程中，改变前x = 100， 改变后x = 6，最终程序输出6。  
2 